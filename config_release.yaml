# TODO add general description
# TODO merge with cfg.yaml from spaceborne_covg
# TODO add dzGC

cosmology:
    # these are the parameters varied in the analysis. The ordering is the same used in the FM 
    FM_ordered_params:
        Om: 0.318592238
        ODE: 0.68140775651
        Ob: 0.05001413
        wz: -1.0
        wa: 0.0
        h: 0.6737
        ns: 0.966
        s8: 0.816
        logT: 7.75
        Aia: 0.16
        eIA: 1.66
        m01: 0.0
        m02: 0.0
        m03: 0.0
        m04: 0.0
        m05: 0.0
        m06: 0.0
        m07: 0.0
        m08: 0.0
        m09: 0.0
        m10: 0.0
        m11: 0.0
        m12: 0.0
        m13: 0.0
        dzWL01: -0.025749
        dzWL02: 0.022716
        dzWL03: -0.026032
        dzWL04: 0.012594
        dzWL05: 0.019285
        dzWL06: 0.008326
        dzWL07: 0.038207
        dzWL08: 0.002732
        dzWL09: 0.034066
        dzWL10: 0.049479
        dzWL11: 0.06649
        dzWL12: 0.000815
        dzWL13: 0.04907
        # coefficients for the polynomial magnification and galaxy bias fits
        bG01: 1.33291
        bG02: -0.72414
        bG03: 1.0183
        bG04: -0.14913
        bM01: -1.50685
        bM02: 1.35034
        bM03: 0.08321
        bM04: 0.04279

    # these parameters are not varied in the analysis; their specific ordering is not important
    # TODO how about logT? below it's fixed, above it's varied
    other_params:
        m_nu: 0.06
        N_eff: 3.046
        bIA: 0.0
        CIA: 0.0134
        Om_k0: 0
        camb_extra_parameters:
            camb:
                halofit_version: mead2020_feedback
                HMCode_logT_AGN: 7.75
                num_massive_neutrinos: 1
                dark_energy_model: ppf


general_cfg:
    ell_min: 10
    ell_max_WL: 3000
    ell_max_GC: 3000
    ell_max_3x2pt: 3000
    zbins: 13
    EP_or_ED: EP  # equipopulated or equidistant bins
    n_probes: 2
    use_WA: False
    save_cls_3d: False
    save_rls_3d: False

    # the case with the largest range is nbl_WL_opt.. This is the reference ell binning from which the cuts are applied;
    # in principle, the other binning should be consistent with this one and should not be hardcoded, as long as
    # lmax=5000, 3000 holds
    nbl_WL_opt: 32  # this is the value from which the various bin cuts are applied, do not change it
    ell_max_WL_opt: 5000  # this is the value from which the various bin cuts are applied, do not change it

    ell_cuts: False
    which_cuts: Vincenzo
    center_or_min: center  # cut if the bin *center* or the bin *lower edge* is larger than ell_max[zi, zj]
    cl_ell_cuts: False
    kmax_h_over_Mpc_ref: 1.0  # this is used when ell_cuts is False, also...?
    # kmax_list_1_over_Mpc: (0.25, 0.50, 0.75, 1.00, 1.25, 1.50, 1.75, 2.00, 3.00, 5.00, #10.00)),
    # kmax_h_over_Mpc_list: [0.37108505, 0.74217011, 1.11325516, 1.48434021, 1.85542526,
    #                                   2.22651032, 2.59759537, 2.96868042, 4.45302063, 7.42170105, 14.84340211]
    kmax_h_over_Mpc_list: [0.1, 0.16681005, 0.27825594, 0.46415888, 0.77426368, 1.29154967, 2.15443469, 3.59381366, 5.9948425, 10.]

    BNT_transform: False  # ! to be deprecated?
    cl_BNT_transform: False


    cl_folder: SPV3_folder + /OutputFiles/DataVectors/Noiseless/{which_pk:s}
    rl_folder: f{SPV3_folder} + /OutputFiles/ResFun/{which_pk:s}
    cl_filename: dv-{probe:s}-{EP_or_ED:s}{zbins:02d}-ML{magcut_lens:03d}-MS{magcut_source:03d}-idIA{idIA:d}-idB{idB:d}-idM{idM:d}-idR{idR:d}.dat
    rl_filename: resfun-idBM{idBM:02d}.dat  # XXX its idBM... anyway not using the responses at the moment

    has_rsd: False
    has_magnification_bias: True

    magcut_source: 245
    magcut_lens: 245

    which_forecast: SPV3
    bias_function: analytical  # 'analytical', 'leporifit', 'pocinofit'
    bias_model: step-wise  # 'step-wise', 'constant', 'linint', 'ones', 'polynomial'



covariance_cfg:

    # ordering-related stuff
    triu_tril: triu
    row_col_major: row-major
    block_index: ell
    GL_or_LG: GL

    which_probe_response: variable
    response_const_value: None  # it used to be 4 for a constant probe response, which is quite wrong

    fsky: 0.3563380664078408  # ! new
    sigma_eps_i: 0.26  # ellipticity dispersion *per component*; sigma_eps: (0.26 * np.sqrt(2))

    nofz_folder: /home/davide/Documenti/Lavoro/Programmi/common_data/vincenzo/SPV3_07_2022/LiFEforSPV3/InputFiles/InputNz/NzFid/
    nofz_filename: nzTab-EP13-zedMin02-zedMax25-mag245.dat

    zbin_centers: [0.27575, 0.37635, 0.44634, 0.54284, 0.62145, 0.70957, 0.7986, 0.86687, 0.97753, 1.09136, 1.24264, 1.47918, 1.89264]
    # number of galaxies per arcmin**2 for each redshift bin. 
    ngal_lensing: [1.86742, 1.86744, 1.8674 , 1.86743, 1.86741, 1.86742, 1.86742, 1.86742, 1.86744, 1.8674 , 1.86742, 1.86742, 1.86742]
    ngal_clustering: [1.86742, 1.86744, 1.8674 , 1.86743, 1.86741, 1.86742, 1.86742, 1.86742, 1.86744, 1.8674 , 1.86742, 1.86742, 1.86742]


    shift_nz: True  # ! are vincenzos kernels shifted?? it looks like they are not
    compute_bnt_with_shifted_nz_for_zcuts: False  # ! lets test this
    shift_nz_interpolation_kind: linear
    normalize_shifted_nz: True
    nz_gaussian_smoothing: False  # does not seem to have a large effect...
    nz_gaussian_smoothing_sigma: 2
    include_ia_in_bnt_kernel_for_zcuts: False


    plot_nz_tocheck: True

    cov_BNT_transform: False
    cov_ell_cuts: False

    compute_covmat: True
    compute_SSC: True

    save_cov: False
    cov_file_format: npz  # or npy
    save_cov_dat: False  # this is the format used by Vincenzo

    # in cov_dict
    save_cov_2D: False
    save_cov_4D: False
    save_cov_6D: False  # or 10D for the 3x2pt
    save_cov_GO: False
    save_cov_GS: False
    save_cov_SSC: False
    save_2DCLOE: False  # outermost loop is on the probes
    covariance_ordering_2D: ell_probe_zpair

    compute_GSSC_condition_number: False

    # ! no folders for ell_cut_center or min
    cov_folder: f{DATA_ROOT}/output/Flagship_{flagship_version}/covmat/BNT_{BNT_transform} + /ell_cuts_{cov_ell_cuts:s}
    cov_filename: covmat_{which_cov:s}_{ng_cov_code:s}_{probe:s}_zbins{EP_or_ED:s}{zbins:02d}_
                    ML{magcut_lens:03d}_ZL{zcut_lens:02d}_MS{magcut_source:03d}_ZS{zcut_source:02d}_
                    idIA{idIA:1d}_idB{idB:1d}_idM{idM:1d}_idR{idR:1d}_pk{which_pk:s}_{ndim:d}D + fm_and_cov_suffix

    SSC_code: OneCovariance  # ! PySSC or PyCCL or Spaceborne or OneCovariance

    PyCCL_cfg: 
        probe: 3x2pt
        # cNG or SSC. Which non-Gaussian covariance terms to compute. Must be a tuple
        which_ng_cov: (SSC )
        test_GLGL: False  # must be set to False for actual 3x2pt runs
        
        which_pk_for_pyccl: PyCCL  # PyCCL (the one stored in cosmo obj) or CLOE (from input files - to be implemented)

        load_precomputed_cov: True
        save_cov: True
        
        load_precomputed_tkka: False
        save_hm_responses: True
        save_tkka: True

        cov_path: f{DATA_ROOT}/output/Flagship_{flagship_version}/covmat/PyCCL + fm_last_folder
        cov_filename: cov_{which_ng_cov:s}_pyccl_{probe_a:s}{probe_b:s}{probe_c:s}{probe_d:s}_4D_
                        nbl{nbl:d}_ellmax{lmax:d}_zbins{EP_or_ED:s}{zbins:02d} + fm_and_cov_suffix + .npz


        which_sigma2_B: mask  # mask or spaceborne (with mask) or None
        area_deg2_mask: 14700
        nside_mask: 2048
        ell_mask_filename: ROOT + /common_data/mask/ell_circular_1pole_{area_deg2:d}deg2_nside{nside:d}.npy
        cl_mask_filename: ROOT + /common_data/mask/Cell_circular_1pole_{area_deg2:d}deg2_nside{nside:d}.npy
        # z_grid_sigma2_B_filename: ROOT + /exact_SSC/output/sigma2/z_grid_sigma2_zsteps3000_ISTF.npy
        # sigma2_B_filename: ROOT + /exact_SSC/output/sigma2/sigma2_zsteps3000_ISTF.npy
        sigma2_suffix: mask  # this is the filename suffix for the sigma2_B file saved directly from cov_SSC in CCL

        # z_grid min and max should probably coincide. play around with steps to find the minimum number
        z_grid_tkka_min: 0.
        z_grid_tkka_max: 6
        k_grid_tkka_min: 1e-5
        k_grid_tkka_max: 1e2
        z_grid_tkka_steps_SSC: 200
        k_grid_tkka_steps_SSC: 1024
        z_grid_tkka_steps_cNG: 100
        k_grid_tkka_steps_cNG: 512
        
        n_samples_wf: 1000
    

    Spaceborne_cfg: 
        probe: 3x2pt
        which_ng_cov: [SSC, ]  # only SSC available in this case
        load_precomputed_cov: True  # always True for the moment, I have to compute the integral with Julia

        cov_path: DATA_ROOT/output/Flagship_{flagship_version}/covmat/Spaceborne/separate_universe + fm_last_folder
        cov_filename: cov_{which_ng_cov:s}_spaceborne_{probe_a:s}{probe_b:s}{probe_c:s}{probe_d:s}_4D_nbl{nbl:d}_ellmax{lmax:d}
                        # _zbins{EP_or_ED:s}{zbins:02d}_zsteps{z_steps_sigma2:d}_k{k_txt_label:s}
                        # _convention{cl_integral_convention:s}.npy

        # settings for sigma2
        cl_integral_convention: PySSC  # or Euclid, but gives same results as it should!!! TODO remove this
        k_txt_label: 1overMpc
        use_precomputed_sigma2: True  # still need to understand exactly where to call/save this
        z_min_sigma2: 0.001
        z_max_sigma2: 3
        z_steps_sigma2: 2899
        log10_k_min_sigma2: -4
        log10_k_max_sigma2: 1
        k_steps_sigma2: 20_000

    OneCovariance_cfg: 
        which_ng_cov: [cNG, ]
        load_precomputed_cov: True  # this must be True for OneCovariance
        use_OneCovariance_Gaussian: False

        cov_path: f{DATA_ROOT}/output/Flagship_2/covmat/OneCovariance/output_SPV3_v3_dense_LiFECls
        cov_filename: cov_{which_ng_cov:s}_onecovariance_{probe_a:s}{probe_b:s}{probe_c:s}{probe_d:s}_4D_nbl{nbl:d}_ellmax{lmax:d}_zbins{EP_or_ED:s}{zbins:02d}.npz


FM_cfg: 
    compute_FM: True

    save_FM_txt: True
    save_FM_dict: True

    load_preprocess_derivatives: False
    derivatives_folder: SPV3_folder/OutputFiles/DataVecDers/{flat_or_nonflat:s}/{which_pk:s}/{EP_or_ED:s}{zbins:02d}

    derivatives_filename: dDVd{param_name:s}-{probe:s}-ML{magcut_lens:03d}-MS{magcut_source:03d}-{EP_or_ED:s}{zbins:02d}.dat

    derivatives_BNT_transform: False
    deriv_ell_cuts: False

    fm_folder: f{DATA_ROOT}/output/Flagship_{flagship_version}/FM/BNT_{BNT_transform:s}/ell_cuts_{ell_cuts:s}/{which_cuts:s}/ell_{center_or_min:s}{fm_last_folder}
    fm_last_folder: fm_last_folder
    fm_txt_filename: fm_txt_filename
    fm_dict_filename: fm_dict_filename


